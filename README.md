# NEXT2024
This repository holds my submission package (Slime Wars) for Ubisoft NEXT 2024, including the supplementary documentation, my preparatory research materials and resources used, and the lessons I took away throughout the competition process!

## Credits
Before diving into the submission specifics, I would like to take this time to mention all the amazing artwork open to the internet and help that I received to develop my learning that had made my game the game it is today. I couldn't have done it without the help! :)

 1. Ubisoft Toronto (Develop At Ubisoft [DAU] & Ubisoft NEXT) - Included in the credits but also a learning resource! Participating in DAU and NEXT multiple times really helped me understand my next steps in learning and introduced me to learning resources along the way!
 2. Background (CraftPix.net 2D Game Assets) - [Summer pixel art seamless background | OpenGameArt.org](https://opengameart.org/content/summer-pixel-art-seamless-background)
 3. Old Cannon (King Kelpo) - [Old Cannon by KingKelpo (itch.io)](https://kingkelp.itch.io/old-cannon)
 4. Slime (Calciumtrice) - [Animated Slime | OpenGameArt.org-> Calciumtrice](https://opengameart.org/content/animated-slime)
 5. Projectile (Jesse McCarthy) - [Splash Effect [32x32] | OpenGameArt.org](https://opengameart.org/content/splash-effect-32x32)
 6. Heart Pixel Art (Flixberry Entertainment) - [heart pixel art | OpenGameArt.org, DontMind8.blogspot.com](https://opengameart.org/content/heart-pixel-art)
 7. Cannon SFX (Courtesy of the test files included in the provided API) - https://toronto.ubisoft.com/next/ 

## The Process
1. As the day approached for the complete brief and programming challenge theme to be released, I readied myself both mentally and with the tools I needed to start. I implemented a basic `World` class to create, run, and delegate update functionality to `Level` classes (empty at the time) and an entity component system with basic component types that would be contained within the `Level` classes and individually updated. I also prepared designs of how I wanted object pooling to work out and listed my preliminary goals for the submission of what features I would have liked to include to showcase my strengths.
2. Once the theme was released, I was really excited to hear that the theme was "Projectiles". My top list of goals included being able to implement Object Pooling, and so projectiles was just what I wanted and perfect for the occasion! But from there came how I could tweak game mechanics to fit the rest of the list into my submission: Behaviour Trees and Vector math.
3. My greatest struggle was that I immediately thought of a bubble shooter when I came across the projectiles theme. Inspiration would be taken from Angry Birds, but I was also extremely adamant about keeping elements of one of my favorite arcade genres that followed me through childhood. And so, I stuck with it, regardless of what it had to do with the list of key features I wanted to include. But keeping the bubble shooter genre would mean that I needed something extra to add to the equation to tie in the rest of the elements, and that's where the tower defense-y elements came in. Why not play around with how the "bubbles" come to you to add the complexity of AI? And thus, the idea was born.
4. From there, I thought of ways to add more behaviour to the movement of the bubbles and I really wanted to simulate a "3D-ness" to the world, so I created the lanes and scaled the sprites to appear closer or farther from the screen.
5. Once the design was finished and I completed my countless drawings on paper, I laid out milestones of what I wanted to achieve by day and mapped out tasks to complete in numerical order. This greatly helped to always keep myself on track and on my toes to adjust my strategy when needed, especially when bugs come out of the woodwork or a task takes longer than expected, etc. From there, I programmed all to the submission deadline and saved plenty of time to record my submission and write out necessary documentation (I made the mistake of pushing this off too late before unfortunately :) ).

## Learning Resources
Here is a list of all the learning resources and materials that have directly played a role in aiding me to develop my final submission!

1. C++ for Programmers Third Edition (Leen Ammeraal)
   -> When submitting this game, I came in with most of my knowledge of C++ 98 from studying this source, so many of my learning outcomes have developed around refactoring changes from C++ 98 features to modern C++ 11 and onward.
2. The C++ Programming Language Special Third Edition (Bjarne Stroustrup)
   -> Widely used in conjunction with cppreference to better understand modern C++ and its evolution from C++ 98.
3. cppreference - https://en.cppreference.com/w/
  -> Cppreference was widely used to fill in the blanks of my understanding of modern C++ when going into this event. I realized how different of a world modern C++ is from C++ 98, so this source helped me tremendously to get an overview of the evolution of the C++ releases and their features.
4. Game Programming Patterns (Robert Nystrom) - https://gameprogrammingpatterns.com/
   -> A tremendous resource to learn game programming patterns and a great read altogether!
5. Design Patterns (Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides)
   -> The programming patterns written by the Gang of Four referenced in "Game Programming Patterns"!
7. Math for Game Devs [2022] (Freya HolmÃ©r) - https://www.youtube.com/@acegikmo/featured, https://dev.to/hanselminutes/visualizing-math-with-freya-holmer
   -> Although I studied this resource far back and do still need to touch up on my math skills, these resources have been a tremendous help in understanding and visualizing the math that plays a major role in game development to aid in my learning for the competition!
8. Unreal Engine 5 Documentation - https://dev.epicgames.com/documentation/en-us/unreal-engine/programming-with-cplusplus-in-unreal-engine
   -> This may seem out of the box, but working with Unreal Engine and its documentation did get me to learn about its architecture as a role model of sorts and help facilitate ideas towards how I would envision my game to work.

## Learning Outcomes
If I could go back and redo everything again, here is a small list of the major changes I would make (special thanks to the Ubisoft Toronto judges for Ubisoft NEXT that helped me come to these understandings throughout the interview process!):

1. Taking care for memory safety - The lack of smart pointers is pretty horrendous looking back on my submission! Smart pointers are very important to assign ownership of memory to specific classes (helps communicate this to the reader too in the header file!) and to prevent memory-related bugs from being introduced by the programmer. As hard as we try, humans are prone to make mistakes, so just reminding myself to make sure to free the memory after allocating it or taking care for dangling pointers like I did for this submission is still very bug prone, especially when the codebase gets very large and harder to manage. All in all, it's better to have the smart pointers take care of it for you!
2. Remove the boilerplate feeling and promote easier editing experiences - As I built the game throughout the weekend, I felt over time that I kept making new classes for new features I wanted for the core components (`ControllerComponent`, `PhysicsComponent`, `RendererComponent`) which I would then scrutinize over having certain class attributes be inherited all from the parent class or only be limited to other subclasses. This caused some time to be wasted over constantly readjusting the parent component classes and soon after requiring a refactor of all subclasses when refactoring those parent classes. Additionally, I did tend to feel that the benefits of OOP were not being completely extracted at their best and creating new components felt boilerplate to always require a new class for every new feature or functionality that I desired and to hardcode the instantiation of new objects. If I were to redo this process, I would like to set concrete goals over inheritance structures from the beginning and implement file parsing and level design tools to dynamically adjust the level layout and its workings for greater flexibility. Currently, the ability to work with others and allow for the use of the tools created for this game to update it without code is absolutely horrendous :)! Everything is hardcoded, and so, I believe at least offering adjustments to the level design and workings of the game through readable files is the way to go!
3. Frame Rate Independence - Even as I write this, I'm kicking myself here. I thought I implemented movement with respect to delta time, and when I checked my submission again, that wasn't the case!
4. Adjust Object Pooling - The "Set Data" class member functions ended up becoming shortcuts to complete object pooling through the passing of data to pooled and reused objects, yet it surely isn't a great course of action. Along with all the function overloads, "Set Data" isn't exactly the greatest description or name to explain to the reader what it is used for and so reasoning about the working of subclasses becomes much harder with this code smell. Another adjustment would be to instead implement Object Pooling with a `Stack` to reap the benefits of LIFO. Since objects recently added to the pool would be the first to be taken from the pool, using a `Stack` would likely result in greater cache hits and performance.
5. Transformation Matrices - I thought it may have been cheaper to simulate scaling of the sprites through vectors alone but transformation matrices would have made calculations simpler and easier to read.
6. Behaviour Trees - I came into this event wanting to implement AI with BTs and came out not implementing BTs. If I could redo this submission and hopefully come out with more time to implement the BTs I would have. My original plan was to implement more complexity to the movement of the slime creatures such as switching between lanes, slowing down and speeding up at different points in time, etc. to force the player into requiring more strategy and timing to create destructive combos when defeating enemies. However, I was on the fence taking considerations of scope and how smarter AI would affect the game loop and it really would be a gamble to weigh the costs of memory and time taken to process the AI frame by frame against the complexity and flavor the AI would add to make or break the gameplay experience.

## Closing Statement
If you've made it this far, thank you so much for reading through my process and thoughts! I would like to thank everyone for their support and especially Ubisoft Toronto for faciliating such an event to help me learn and grow! 
Cheers! :)
